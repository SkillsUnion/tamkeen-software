## Refactoring `SimpleCrm` to Use PostgreSQL

### Lesson Objectives:

  - Learn how to integrate Java Persistence API (JPA) with PostgreSQL for building robust, production-ready database solutions.

  - Implement JPA in the `SimpleCrm` project, including creating entities, repositories, and service layers for handling database operations.


### JPA and PostgreSQL

This lesson introduces Java Persistence API (JPA) with PostgreSQL and guides you through refactoring the `SimpleCrm` project to use JPA with PostgreSQL. It covers creating the entity, repository, service layer, and controller layer, as well as configuring and testing the application.

---

### JPA
- JPA (**Jakarta Persistence API**) is a specification for mapping Java objects to relational databases using Object Relational Mapping (ORM).
- Hibernate is the default implementation of JPA in Spring Boot, providing a framework for handling data persistence.

### PostgreSQL
PostgreSQL is an open-source relational database management system known for its reliability, performance, and robust feature set. It is production-ready, making it a preferred choice over in-memory databases like H2.

---

## Setting Up PostgreSQL and JPA dependencies:

### Adding Required Dependencies

#### To enable JPA and PostgreSQL integration in your Spring Boot project, include the following dependencies in your `pom.xml`:

```xml

    <!-- Spring Data JPA for ORM support -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>

    <!-- PostgreSQL JDBC Driver -->
    <dependency>
        <groupId>org.postgresql</groupId>
        <artifactId>postgresql</artifactId>
    </dependency>

```

#### Make sure you have already created database simple_crm after installing postgreSQL and Dbeaver.
###### If not created the database, refer to the last lesson on installation and create a database simple_crm first.

### Configuring PostgreSQL
Next, we need to update the  `application.properties` with PostgreSQL settings:
```properties
spring.datasource.url=jdbc:postgresql://localhost:5432/simple_crm
spring.datasource.username=postgres
spring.datasource.password=
spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.hibernate.ddl-auto=create
```

### Create a JPA Entity

What is an entity? It is a Java class that is mapped to a database table. The objects of this class will be managed by JPA and persisted to the database for us.

In our `Customer` class, we will add the `@Entity` annotation to indicate that it is an entity. This tells JPA that this class is to be mapped to a database table.

We will also add the `@Table` annotation to specify the name of the database table that this entity will be mapped to.

```java
@Entity
@Table(name = "customer")
public class Customer {
  // ...
}
```

### Define a Primary Key and Name the Columns

What is a **primary key (PK)**? It is a column in a database table that uniquely identifies each row in that table. It is used to ensure that each row in a table is unique. For example, in a `customers` table, the PK could be the `id` column.

| id ðŸ”‘ | name    | email               |
| ----- | ------- | ------------------- |
| 1     | Alice   | alice@example.com   |
| 2     | Bob     | bob@example.com     |
| 3     | Charlie | charlie@example.com |

We can tell JPA which column is the primary key by adding the `@Id` annotation to the field.

For the PK, we will use a `Long` type and annotate it with `@Id` and `@GeneratedValue`. The `@GeneratedValue` annotation is used to specify the strategy for generating the PK values. We will use the `GenerationType.IDENTITY` strategy, which means that the PK values will be generated by the database.

These are the available strategies:

| Strategy                  | Description                                                                                                                              |
| ------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------- |
| `GenerationType.AUTO`     | Indicates that the persistence provider should pick an appropriate strategy for the particular database. This is the default strategy.   |
| `GenerationType.IDENTITY` | Indicates that the persistence provider must assign primary keys for the entity using a database identity column.                        |
| `GenerationType.SEQUENCE` | Indicates that the persistence provider must assign primary keys for the entity using a database sequence.                               |
| `GenerationType.TABLE`    | Indicates that the persistence provider must assign primary keys for the entity using an underlying database table to ensure uniqueness. |

It is also possible to use a custom generator. You can read more about the generators [here](https://www.baeldung.com/hibernate-identifiers).

Next we will add the `@Column` annotation to the `id` field to specify the name of the column in the database table that this field will be mapped to.

```java
@Id
@GeneratedValue(strategy = GenerationType.IDENTITY)
@Column(name = "id")
private Long id;
```

And proceed to do the same for the other fields. For multiple words, the convention is to use snake case e.g. `first_name`.

### After making all the changes, The entity Customer should look like this:


```java
@Entity
@Table(name = "customer")
public class Customer {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "first_name")
    private String firstName;

    @Column(name = "last_name")
    private String lastName;

    @Column(name = "email")
    private String email;

    @Column(name = "contact_no")
    private String contactNo;

    @Column(name = "job_title")
    private String jobTitle;

    @Column(name = "year_of_birth")
    private int yearOfBirth;

    // include Getters, setters, and constructors
}
```

Now, run the app and check 

The table should have been created for us but it has no data. Let's add some data.

How we would do it in SQL would be something like this:

```sql
INSERT INTO customer (first_name, last_name, email, contact_no, job_title, year_of_birth)
VALUES ('John', 'Doe', 'john.doe@example.com', '12345678', 'Software Engineer', 1985);
```


---

### Creating the Repository :

### Set Up the Repository

Now, we need to create a repository to interact with the database. As you might recall, the repository is the layer that handles the data access logic.

This time though, we do not need to define a repository class. Instead, we will define a `CustomerRepository` interface that extends the `JpaRepository` interface. You can rename the current `CustomerRepository.java` to `CustomerRepository.java.old` for reference. Then create a new `CustomerRepository.java`.

```java
public interface CustomerRepository extends JpaRepository<Customer, Long> {
}
```

In the type parameters, we specify the entity type and the type of the primary key, which in this case, are `Customer` and `Long` respectively.

The `JpaRepository` interface provides us with many methods for interacting with the database. The good thing is, we do not need to write any code to implement these methods. Spring JPA will automatically generate the implementation for us. This will then become a bean in our Spring container, which we can inject into our service layer.

Note that we also did not have to annotate the interface with `@Repository` because this will be handled by Spring JPA

### Building the Service Layer :

Refactor the `CustomerService` to include business logic and interact with the repository:
```java
@Service
public class CustomerServiceImpl implements CustomerService {
    private final CustomerRepository customerRepository;

    @Autowired
    public CustomerServiceImpl(CustomerRepository customerRepository) {
        this.customerRepository = customerRepository;
    }

    @Override
    public Customer createCustomer(Customer customer) {
        return customerRepository.save(customer);
    }

    @Override
    public Customer getCustomer(Long id) {
        return customerRepository.findById(id)
                .orElseThrow(() -> new CustomerNotFoundException(id));
    }

    @Override
    public List<Customer> getAllCustomers() {
        return customerRepository.findAll();
    }

    @Override
    public Customer updateCustomer(Long id, Customer customer) {
        Customer existingCustomer = getCustomer(id);
        existingCustomer.setFirstName(customer.getFirstName());
        existingCustomer.setLastName(customer.getLastName());
        // Update other fields...
        return customerRepository.save(existingCustomer);
    }

    @Override
    public void deleteCustomer(Long id) {
        customerRepository.deleteById(id);
    }
}
```

Also, the helper method `getCustomerIndex` can also be removed since we are no longer using it.


---

### Updating CustomerController and CustomerService interface

Finally, we have to update the type of the id in our `CustomerController` and the `CustomerService` interface, since we are now using a `Long` type instead of a `String` type for the `id`.

Change `String` to `Long` in `CustomerController`:

```java
@GetMapping("{id}")
public ResponseEntity<Customer> getCustomer(@PathVariable Long id)

@PutMapping("{id}")
public ResponseEntity<Customer> updateCustomer(@PathVariable Long id, @RequestBody Customer customer)

@DeleteMapping("{id}")
public ResponseEntity<HttpStatus> deleteCustomer(@PathVariable Long id)
```

Change `String` to `Long` in the `CustomerService` interface:

```java
public interface CustomerService {
  Customer createCustomer(Customer customer);

  Customer getCustomer(Long id);

  ArrayList<Customer> getAllCustomers();

  Customer updateCustomer(Long id, Customer customer);

  void deleteCustomer(Long id);

}
```

###   After refactoring, the Controller Layer should look like this :

The controller layer handles HTTP requests and communicates with the service layer:
```java
@RestController
@RequestMapping("/customers")
public class CustomerController {
    private final CustomerService customerService;

    @Autowired
    public CustomerController(CustomerService customerService) {
        this.customerService = customerService;
    }

    @PostMapping("")
    public ResponseEntity<Customer> createCustomer(@RequestBody Customer customer) {
        Customer newCustomer = customerService.createCustomer(customer);
        return new ResponseEntity<>(newCustomer, HttpStatus.CREATED);
    }

    @GetMapping("")
    public ResponseEntity<List<Customer>> getAllCustomers() {
        List<Customer> allCustomers = customerService.getAllCustomers();
        return new ResponseEntity<>(allCustomers, HttpStatus.OK);
    }

    @GetMapping("/{id}")
    public ResponseEntity<Customer> getCustomer(@PathVariable Long id) {
        Customer customer = customerService.getCustomer(id);
        return new ResponseEntity<>(customer, HttpStatus.OK);
    }

    @PutMapping("/{id}")
    public ResponseEntity<Customer> updateCustomer(@PathVariable Long id, @RequestBody Customer customer) {
        Customer updatedCustomer = customerService.updateCustomer(id, customer);
        return new ResponseEntity<>(updatedCustomer, HttpStatus.OK);
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteCustomer(@PathVariable Long id) {
        customerService.deleteCustomer(id);
        return new ResponseEntity<>(HttpStatus.NO_CONTENT);
    }
}
```
---
##  Preloading Data with a `DataLoader` class

Lets preload data into the database.

Create a custom `DataLoader` class and annotate it with `@Component`. We can then load the data in method annotated with `@PostConstruct`. This method will be called after the bean has been created by Spring.

```java
@Component
public class DataLoader {
  private CustomerRepository customerRepository;

  @Autowired
  public DataLoader(CustomerRepository customerRepository) {
    this.customerRepository = customerRepository;
  }

  @PostConstruct
  public void loadData() {
    // clear the database first
    customerRepository.deleteAll();

    // load data here
    customerRepository.save(new Customer("Tony", "Stark"));
    customerRepository.save(new Customer("Bruce", "Banner"));
    customerRepository.save(new Customer("Peter", "Parker"));
    customerRepository.save(new Customer("Stephen", "Strange"));

  }
}
```

The advantage of this approach is that it is independent of the database type since we are using JPA. This means that we can switch to a different database without having to change the code. In addition, if we want to turn this off, we can simply comment out the `@Component` annotation.

---

###  Testing the Application

1. **Run the Application**  
   Start the Spring Boot application and ensure PostgreSQL is being used.

2. **Test Endpoints**  
   Use tools like Postman to create and retrieve customers.

3. **Verify in PostgreSQL**  
   Check the database to ensure data persistence.

---

This lesson introduces JPA and PostgreSQL integration while guiding you through refactoring the `SimpleCrm` project with an emphasis on robust, production-ready practices.


##  `Optional` and Exception Handling

Currently, in our `CustomerServiceImpl`, we are doing this:

```java
@Override
public Customer getCustomer(Long id) {
    Customer foundCustomer = customerRepository.findById(id).get();
    return foundCustomer;
}
```

What happens when we get a customer id that does not exist?

If you look at the `findById` method in the `CustomerRepository` interface, you will see that it actually returns an `Optional`.

An `Optional` is a container object that may or may not contain a non-null value. It is used to represent the presence or absence of a value.

Hence, we had to use `get()` to unwrap the `Optional` and get the `Customer` object. However, this is not a good practice. If the result is `null`, we will get a `NoSuchElementException`. You can try getting an invalid id.

We should check if the `Optional` contains a value before unwrapping it.

```java
@Override
public Customer getCustomer(Long id) {
    Optional<Customer> optionalCustomer = customerRepository.findById(id);
    if (optionalCustomer.isPresent()) {
        // If the Optional contains a value, unwrap it and return the Customer object
        Customer foundCustomer = optionalCustomer.get();
        return foundCustomer;
    }

    throw new CustomerNotFoundException(id);
}
```

Test getting an invalid id.

This can also be further simplified with `orElseThrow()`.

The method `customerRepository.findById(id)` will return an `Optional<Customer>`. `Optional` has a method `orElseThrow()` that will return the value if it is present, or throw an exception if it is not present. We can then use a lambda expression to throw a `CustomerNotFoundException` if the value is not present.

```java
@Override
public Customer getCustomer(Long id) {
    return customerRepository.findById(id).orElseThrow(() -> new CustomerNotFoundException(id));
}
```

You can use whichever method you think is more readable.

Currently, we are only getting a 404 error. We are not getting a proper error message, which may not be very helpful to the user.

We could return the error message as a string, but our `ResponseEntity` is of type `Customer`. So we could change the type parameter of `ResponseEntity` to `Object`, which is the parent class of all classes in Java.

```java
@GetMapping("{id}")
public ResponseEntity<Object> getCustomer(@PathVariable Long id) {

    try {
        Customer foundCustomer = customerService.getCustomer(id);
        return new ResponseEntity<>(foundCustomer, HttpStatus.OK);
    } catch (CustomerNotFoundException e) {
        return new ResponseEntity<>(e.getMessage(), HttpStatus.NOT_FOUND);
    }
}
```

With this, we could return a `Customer` object if the customer is found, or a string if the customer is not found. But we lose the type safety. This means we could return any object, not just a `Customer` object.

Another problem we have now is that we have all these `try-catch` blocks in our controller.

---

##  Global Exception Handler

Spring Boot lets us create a global exception handler to handle all exceptions in our application using the `@ControllerAdvice` annotation. This allows us to define a centralized place to handle exceptions thrown from all controllers in our application.

<img src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*Rr3r5KfKYc6fVJfTZF-rHA.png" width=550 style="background-color: #fff;padding: 25px; border: 1px solid #333;border-radius: 5px">

> Source: https://medium.com/@praneshgupta/springboot-exception-handling-in-apis-globalexceptionhandler-c549470f7834

Create a new class `GlobalExceptionHandler.java`.

Each exception handler method can be annotated with `@ExceptionHandler` to handle a specific exception.

```java
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;

@ControllerAdvice
public class GlobalExceptionHandler {

    // This is a handler for CustomerNotFoundException
    @ExceptionHandler(CustomerNotFoundException.class)
    public ResponseEntity<String> handleCustomerNotFoundException(CustomerNotFoundException ex) {
        return new ResponseEntity<>(ex.getMessage(), HttpStatus.NOT_FOUND);
    }
}
```

Hence we no longer need the `try-catch` block in our controller. And we also do not have to return a `ResponseEntity<Object>` and instead return our original `ResponseEntity<Customer>`, which gives us type safety.

```java
@GetMapping("{id}")
public ResponseEntity<Customer> getCustomer(@PathVariable Long id) {
    Customer foundCustomer = customerService.getCustomer(id);
    return new ResponseEntity<>(foundCustomer, HttpStatus.OK);
}
```

Now, when an exception is thrown, it will be caught by this global exception handler. The specific exception handler method will be called to handle the exception.

Currently we are returning it as a string. We could give it a more proper structure by creating a new `ErrorResponse` class .

```java
@Getter
@Setter
@AllArgsConstructor
public class ErrorResponse {
  private String message;
  private LocalDateTime timestamp;
}
```

And update the exception handler method to return an `ErrorResponse` object.

```java
@ExceptionHandler(CustomerNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleCustomerNotFoundException(CustomerNotFoundException ex) {
    ErrorResponse errorResponse = new ErrorResponse(ex.getMessage(), LocalDateTime.now());
    return new ResponseEntity<>(errorResponse, HttpStatus.NOT_FOUND);
}
```

Providing a meaningful error message is useful for our frontend too as it can display the error message to the user.

### General Exception Handler

We can also add a general exception handler to handle all other exceptions that are not handled by the specific exception handlers. This is useful because there may be other exceptions that we have not yet handled or that we did not expect.

For example, currently, we have not handled invalid interactions. Try to get an invalid interaction.

We will get a `NoSuchElementException` when we try to get an interaction that does not exist.

With a general exception handler, we can return a generic error message to the user.

```java
@ExceptionHandler(Exception.class)
public ResponseEntity<ErrorResponse> handleException(Exception ex) {
    // We can log the exception here
    // logger.error(ex.getMessage(), ex);
    // Return a generic error message
    ErrorResponse errorResponse = new ErrorResponse("Something went wrong", LocalDateTime.now());
    return new ResponseEntity<>(errorResponse, HttpStatus.INTERNAL_SERVER_ERROR);
}
```

Try to get an invalid interaction again.

With this in place, the user will get a generic error message when an exception is thrown and we do not have to expose too much information about our application.


