## Refactoring `SimpleCrm` to Use PostgreSQL

### Lesson Objectives:

  - Learn how to integrate Java Persistence API (JPA) with PostgreSQL for building robust, production-ready database solutions.

  - Implement JPA in the `SimpleCrm` project, including creating entities, repositories, and service layers for handling database operations.


### JPA and PostgreSQL

This lesson introduces Java Persistence API (JPA) with PostgreSQL and guides you through refactoring the `SimpleCrm` project to use JPA with PostgreSQL. It covers creating the entity, repository, service layer, and controller layer, as well as configuring and testing the application.

---

### JPA
- JPA (**Jakarta Persistence API**) is a specification for mapping Java objects to relational databases using Object Relational Mapping (ORM).
- Hibernate is the default implementation of JPA in Spring Boot, providing a framework for handling data persistence.

### PostgreSQL
PostgreSQL is an open-source relational database management system known for its reliability, performance, and robust feature set. It is production-ready, making it a preferred choice over in-memory databases like H2.

---

## Setting Up PostgreSQL and JPA dependencies:

### Adding Required Dependencies

#### To enable JPA and PostgreSQL integration in your Spring Boot project, include the following dependencies in your `pom.xml`:

```xml
<dependencies>
    <!-- Spring Data JPA for ORM support -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>

    <!-- PostgreSQL JDBC Driver -->
    <dependency>
        <groupId>org.postgresql</groupId>
        <artifactId>postgresql</artifactId>
    </dependency>
</dependencies>
```



### Configuring PostgreSQL
Next, we need to update the  `application.properties` with PostgreSQL settings:
```properties
spring.datasource.url=jdbc:postgresql://localhost:5432/simple_crm
spring.datasource.username=postgres
spring.datasource.password=
spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.hibernate.ddl-auto=create
```

### Create a JPA Entity

What is an entity? It is a Java class that is mapped to a database table. The objects of this class will be managed by JPA and persisted to the database for us.

In our `Customer` class, we will add the `@Entity` annotation to indicate that it is an entity. This tells JPA that this class is to be mapped to a database table.

We will also add the `@Table` annotation to specify the name of the database table that this entity will be mapped to.

```java
@Entity
@Table(name = "customer")
public class Customer {
  // ...
}
```

### Define a Primary Key and Name the Columns

What is a **primary key (PK)**? It is a column in a database table that uniquely identifies each row in that table. It is used to ensure that each row in a table is unique. For example, in a `customers` table, the PK could be the `id` column.

| id ðŸ”‘ | name    | email               |
| ----- | ------- | ------------------- |
| 1     | Alice   | alice@example.com   |
| 2     | Bob     | bob@example.com     |
| 3     | Charlie | charlie@example.com |

We can tell JPA which column is the primary key by adding the `@Id` annotation to the field.

For the PK, we will use a `Long` type and annotate it with `@Id` and `@GeneratedValue`. The `@GeneratedValue` annotation is used to specify the strategy for generating the PK values. We will use the `GenerationType.IDENTITY` strategy, which means that the PK values will be generated by the database.

These are the available strategies:

| Strategy                  | Description                                                                                                                              |
| ------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------- |
| `GenerationType.AUTO`     | Indicates that the persistence provider should pick an appropriate strategy for the particular database. This is the default strategy.   |
| `GenerationType.IDENTITY` | Indicates that the persistence provider must assign primary keys for the entity using a database identity column.                        |
| `GenerationType.SEQUENCE` | Indicates that the persistence provider must assign primary keys for the entity using a database sequence.                               |
| `GenerationType.TABLE`    | Indicates that the persistence provider must assign primary keys for the entity using an underlying database table to ensure uniqueness. |

It is also possible to use a custom generator. You can read more about the generators [here](https://www.baeldung.com/hibernate-identifiers).

Next we will add the `@Column` annotation to the `id` field to specify the name of the column in the database table that this field will be mapped to.

```java
@Id
@GeneratedValue(strategy = GenerationType.IDENTITY)
@Column(name = "id")
private Long id;
```

And proceed to do the same for the other fields. For multiple words, the convention is to use snake case e.g. `first_name`.

### After making all the changes, The entity Customer should look like this:


```java
@Entity
@Table(name = "customer")
public class Customer {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "first_name")
    private String firstName;

    @Column(name = "last_name")
    private String lastName;

    @Column(name = "email")
    private String email;

    @Column(name = "contact_no")
    private String contactNo;

    @Column(name = "job_title")
    private String jobTitle;

    @Column(name = "year_of_birth")
    private int yearOfBirth;

    // Getters, setters, and constructors
}
```

Now, run the app and check 

The table should have been created for us but it has no data. Let's add some data.

How we would do it in SQL would be something like this:

```sql
INSERT INTO customer (first_name, last_name, email, contact_no, job_title, year_of_birth)
VALUES ('John', 'Doe', 'john.doe@example.com', '12345678', 'Software Engineer', 1985);
```


---

### Creating the Repository :

### Set Up the Repository

Now, we need to create a repository to interact with the database. As you might recall, the repository is the layer that handles the data access logic.

This time though, we do not need to define a repository class. Instead, we will define a `CustomerRepository` interface that extends the `JpaRepository` interface. You can rename the current `CustomerRepository.java` to `CustomerRepository.java.old` for reference. Then create a new `CustomerRepository.java`.

```java
public interface CustomerRepository extends JpaRepository<Customer, Long> {
}
```

In the type parameters, we specify the entity type and the type of the primary key, which in this case, are `Customer` and `Long` respectively.

The `JpaRepository` interface provides us with many methods for interacting with the database. The good thing is, we do not need to write any code to implement these methods. Spring JPA will automatically generate the implementation for us. This will then become a bean in our Spring container, which we can inject into our service layer.

Note that we also did not have to annotate the interface with `@Repository` because this will be handled by Spring JPA

### Building the Service Layer :

Refactor the `CustomerService` to include business logic and interact with the repository:
```java
@Service
public class CustomerServiceImpl implements CustomerService {
    private final CustomerRepository customerRepository;

    @Autowired
    public CustomerServiceImpl(CustomerRepository customerRepository) {
        this.customerRepository = customerRepository;
    }

    @Override
    public Customer createCustomer(Customer customer) {
        return customerRepository.save(customer);
    }

    @Override
    public Customer getCustomer(Long id) {
        return customerRepository.findById(id)
                .orElseThrow(() -> new CustomerNotFoundException(id));
    }

    @Override
    public List<Customer> getAllCustomers() {
        return customerRepository.findAll();
    }

    @Override
    public Customer updateCustomer(Long id, Customer customer) {
        Customer existingCustomer = getCustomer(id);
        existingCustomer.setFirstName(customer.getFirstName());
        existingCustomer.setLastName(customer.getLastName());
        // Update other fields...
        return customerRepository.save(existingCustomer);
    }

    @Override
    public void deleteCustomer(Long id) {
        customerRepository.deleteById(id);
    }
}
```

Also, the helper method `getCustomerIndex` can also be removed since we are no longer using it.


---

### Updating CustomerController and CustomerService interface

Finally, we have to update the type of the id in our `CustomerController` and the `CustomerService` interface, since we are now using a `Long` type instead of a `String` type for the `id`.

Change `String` to `Long` in `CustomerController`:

```java
@GetMapping("{id}")
public ResponseEntity<Customer> getCustomer(@PathVariable Long id)

@PutMapping("{id}")
public ResponseEntity<Customer> updateCustomer(@PathVariable Long id, @RequestBody Customer customer)

@DeleteMapping("{id}")
public ResponseEntity<HttpStatus> deleteCustomer(@PathVariable Long id)
```

Change `String` to `Long` in the `CustomerService` interface:

```java
public interface CustomerService {
  Customer createCustomer(Customer customer);

  Customer getCustomer(Long id);

  ArrayList<Customer> getAllCustomers();

  Customer updateCustomer(Long id, Customer customer);

  void deleteCustomer(Long id);

}
```

###   After refactoring, the Controller Layer should look like this :

The controller layer handles HTTP requests and communicates with the service layer:
```java
@RestController
@RequestMapping("/customers")
public class CustomerController {
    private final CustomerService customerService;

    @Autowired
    public CustomerController(CustomerService customerService) {
        this.customerService = customerService;
    }

    @PostMapping("")
    public ResponseEntity<Customer> createCustomer(@RequestBody Customer customer) {
        Customer newCustomer = customerService.createCustomer(customer);
        return new ResponseEntity<>(newCustomer, HttpStatus.CREATED);
    }

    @GetMapping("")
    public ResponseEntity<List<Customer>> getAllCustomers() {
        List<Customer> allCustomers = customerService.getAllCustomers();
        return new ResponseEntity<>(allCustomers, HttpStatus.OK);
    }

    @GetMapping("/{id}")
    public ResponseEntity<Customer> getCustomer(@PathVariable Long id) {
        Customer customer = customerService.getCustomer(id);
        return new ResponseEntity<>(customer, HttpStatus.OK);
    }

    @PutMapping("/{id}")
    public ResponseEntity<Customer> updateCustomer(@PathVariable Long id, @RequestBody Customer customer) {
        Customer updatedCustomer = customerService.updateCustomer(id, customer);
        return new ResponseEntity<>(updatedCustomer, HttpStatus.OK);
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteCustomer(@PathVariable Long id) {
        customerService.deleteCustomer(id);
        return new ResponseEntity<>(HttpStatus.NO_CONTENT);
    }
}
```
---
##  Preloading Data with a `DataLoader` class

Lets preload data into the database.

Create a custom `DataLoader` class and annotate it with `@Component`. We can then load the data in method annotated with `@PostConstruct`. This method will be called after the bean has been created by Spring.

```java
@Component
public class DataLoader {
  private CustomerRepository customerRepository;

  @Autowired
  public DataLoader(CustomerRepository customerRepository) {
    this.customerRepository = customerRepository;
  }

  @PostConstruct
  public void loadData() {
    // clear the database first
    customerRepository.deleteAll();

    // load data here
    customerRepository.save(new Customer("Tony", "Stark"));
    customerRepository.save(new Customer("Bruce", "Banner"));
    customerRepository.save(new Customer("Peter", "Parker"));
    customerRepository.save(new Customer("Stephen", "Strange"));

  }
}
```

The advantage of this approach is that it is independent of the database type since we are using JPA. This means that we can switch to a different database without having to change the code. In addition, if we want to turn this off, we can simply comment out the `@Component` annotation.

---

###  Testing the Application

1. **Run the Application**  
   Start the Spring Boot application and ensure PostgreSQL is being used.

2. **Test Endpoints**  
   Use tools like Postman to create and retrieve customers.

3. **Verify in PostgreSQL**  
   Check the database to ensure data persistence.

---

This lesson introduces JPA and PostgreSQL integration while guiding you through refactoring the `SimpleCrm` project with an emphasis on robust, production-ready practices.
